from collections.abc import Iterable
from typing import Type


# , возможно, возвращать лучше Type['QHofstadter'].
#  Предварительно импортировав Type из модуля typing.


# , предлагаю попробовать решить задание классов итератором и описать вычисления в методе __next__.
#  В таком случае, цикл while не потребуется. =)
class QHof:

    def __init__(self, number_list: list):
        # , в этот класс стоит передавать список.
        self.Q = number_list
        # , предлагаю перенести в __iter__

    def __iter__(self):
        self.count = 0
        if len(self.Q) != 2 or self.Q != [1, 1]:
            raise StopIteration
        # , стоит добавить переменную счётчик равную "0"
        #  Далее в next первый элемент будет равен "переменная счётчик" + 1 - предыдущее значение
        #  второй элемент будет равен "переменная счётчик" + 1 - ПРЕДпредыдущее значение
        return self

    def __next__(self):
        self.count += 1
        # , введу постоянного роста нашей последовательности,
        #  такая проверка актуальна только на момент создания объекта итератора.
        #  В таком случае, стоит перенести в __iter__.
        # , если длина списка не равна 2 или список не [1, 1],
        #  стоит выйти из последовательности при помощи вызова StopIteration.
        # , следующие действия стоит производить, если текущая длина списка меньше или равна текущему элементу + 1 =)

        if len(self.Q) <= self.count:  # , +1 делаем чуть выше. Если убрать в этом месте, то расчёт получится правильным.
            # , У нас есть алгоритм находения числа
            #  Q(n) = Q(n−Q(n−1))+Q(n−Q(n−2))
            #  В котором Q это наша self.Q, а n это self.count
            #  По идее, мы сейчас разбиваем алгоритм на части
            #  q1 = Q(n−1)
            #  q2 = Q(n−2)
            #  тогда формула будет
            #  Q(n) = Q(n − q1) + Q(n − q2)

            q1 = self.Q[self.count - 1]
            q2 = self.Q[self.count - 2]
            q = self.Q[self.count - q1] + self.Q[self.count - q2]
            # t = self.Q[self.count - self.Q[self.count  - 1]] + self.Q[self.count - self.Q[self.count - 2]]
            self.Q.append(q)
            # , q1 и q2 это индексы списка self.Q =) Предлагаю искать элементы и складывать их.
            # , по идее, за 1 раз необходимо создавать 2 числа и 2 числа добавлять в список.\
            # , по идее q1 и q2 это индексы списка self.Q, предлагаю попробовать добавлять только их сумму. Один раз.
            # , можно перенести эту строку в самое начало текущего метода
            #  В таком случае, в остальных местах кода +1 можно убрать
        # , стоит увеличивать count на 1.
        return self.Q[-1]  #  , возвращать предлагаю элемент который добавили в список. q добавляем не всегда =)


qlist = [1, 1]
Q = QHof(qlist)
# , предлагаю добавить выход из цикла, чтобы было лучше видно, какие элементы выводятся.
#  И возможно, лучше выводить в одну строку.
count = 0
for item in Q:
    count += 1
    print(item, end= " ")
    if count == 100:
        break
