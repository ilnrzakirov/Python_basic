from collections.abc import Iterable
from typing import Type


# , возможно, возвращать лучше Type['QHofstadter'].
#  Предварительно импортировав Type из модуля typing.


# , предлагаю попробовать решить задание классов итератором и описать вычисления в методе __next__.
#  В таком случае, цикл while не потребуется. =)
class QHof:

    def __init__(self):
        # TODO, в этот класс стоит передавать список.
        self.Q = [1, 1]
        self.count = 0 # TODO, предлагаю перенести в __iter__

    def __iter__(self):
        # , стоит добавить переменную счётчик равную "0"
        #  Далее в next первый элемент будет равен "переменная счётчик" + 1 - предыдущее значение
        #  второй элемент будет равен "переменная счётчик" + 1 - ПРЕДпредыдущее значение
        return self

    def __next__(self):
        # TODO, если длина списка не равна 2 или список не [1, 1],
        #  стоит выйти из последовательности при помощи вызова StopIteration.
        q1 = self.count + 1 - self.Q[-1]
        q2 = self.count + 1 - self.Q[-2]
        q = q1 + q2  # TODO, q1 и q2 это индексы списка self.Q =) Предлагаю искать элементы и складывать их.
        # , по идее, за 1 раз необходимо создавать 2 числа и 2 числа добавлять в список.\
        # , по идее q1 и q2 это индексы списка self.Q, предлагаю попробовать добавлять только их сумму. Один раз.
        self.Q.append(q)
        # TODO, стоит увеличивать count на 1.
        return self.Q  # TODO, возвращать предлагаю элемент который добавили в список


def QHofstadter(qlist=list) -> Type["QHofstadter"]:
    # , сисок в решении лишний.
    #  Генератор не должен хранить в себе массивы с данными =)
    n = 2
    while True:
        # , блок try/except лишний.
        q = qlist[n - qlist[n - 1]] + qlist[n - qlist[n - 2]]
        qlist.append(q)
        n += 1
        yield q

qlist = [1, 1]
for item in QHofstadter(qlist):
   print(item)
